/**
 * Atlas Skill System - Action Logging
 *
 * Logs all Atlas actions to Feed 2.0 with intent hashes and pattern fields
 * for future skill detection. This is Phase 1 of the skill-centric architecture.
 *
 * Every action flows through here when ATLAS_SKILL_LOGGING=true
 */

import { Client } from '@notionhq/client';
import { logger } from '../logger';
import { isFeatureEnabled } from '../config/features';
import { generateIntentHash, type IntentHashResult } from './intent-hash';
import type { Pillar, RequestType, StructuredContext } from '../conversation/types';

// Initialize Notion client
const notion = new Client({ auth: process.env.NOTION_API_KEY });

// Feed 2.0 database ID (canonical - from CLAUDE.md)
const FEED_DATABASE_ID = '90b2b33f-4b44-4b42-870f-8d62fb8cbf18';

/**
 * Action types for logging
 */
export type ActionType =
  | 'classify'    // Classification/routing
  | 'query'       // Data queries
  | 'create'      // Creates entries
  | 'update'      // Updates entries
  | 'delete'      // Deletes/archives
  | 'dispatch'    // Agent dispatch
  | 'tool'        // Tool execution
  | 'chat'        // Conversational response
  | 'media'       // Media processing
  | 'extract';    // Content extraction

/**
 * Input for logging an action
 */
export interface ActionLogInput {
  /** The user's original message */
  messageText: string;

  /** Classification pillar */
  pillar: Pillar;

  /** Classification request type */
  requestType: RequestType;

  /** Type of action performed */
  actionType: ActionType;

  /** Tools used during this action */
  toolsUsed: string[];

  /** User ID */
  userId: number;

  /** Classification confidence (0-1) */
  confidence: number;

  /** Whether user confirmed/adjusted classification */
  classificationConfirmed?: boolean;
  classificationAdjusted?: boolean;

  /** What Atlas originally suggested (if adjusted) */
  originalSuggestion?: string;

  /** Execution time in milliseconds */
  executionTimeMs?: number;

  /** Optional entry summary (falls back to messageText) */
  entrySummary?: string;

  /** Optional content type for media/URL shares */
  contentType?: 'image' | 'document' | 'url' | 'video' | 'audio';

  /** Optional source domain for URLs */
  contentSource?: string;

  /** Keywords from classification */
  keywords?: string[];

  /** Work type description */
  workType?: string;

  // Triage Intelligence fields (Sprint: Triage Intelligence)

  /** Triage detected intent */
  triageIntent?: 'command' | 'capture' | 'query' | 'clarify';

  /** Triage complexity tier (0=cache, 1=haiku, 2=sonnet, 3=opus) */
  triageComplexityTier?: 0 | 1 | 2 | 3;

  /** Triage source (pattern_cache or haiku) */
  triageSource?: 'pattern_cache' | 'haiku';

  /** Pillar suggested by triage */
  triageSuggestedPillar?: Pillar;

  /** Whether user corrected triage's pillar suggestion */
  triagePillarCorrected?: boolean;

  /** Triage latency in milliseconds */
  triageLatencyMs?: number;

  /** Smart title generated by triage */
  triageTitle?: string;

  /** Intent-First structured context (Phase 0) */
  structuredContext?: StructuredContext;

  /**
   * Existing Feed entry ID to update instead of creating a new one.
   * Use this when createAuditTrail already created the Feed entry
   * to avoid the dual-write duplicate (Bug A fix).
   */
  existingFeedId?: string;
}

/**
 * Result of action logging
 */
export interface ActionLogResult {
  /** Whether logging was attempted (feature flag) */
  attempted: boolean;

  /** Whether logging succeeded */
  success: boolean;

  /** Intent hash generated */
  intentHash: IntentHashResult | null;

  /** Feed entry ID (if created) */
  feedId?: string;

  /** Error message (if failed) */
  error?: string;
}

/**
 * Log an action to Feed 2.0 with intent hash for pattern detection
 *
 * This is the main entry point for skill action logging.
 * Only logs when ATLAS_SKILL_LOGGING=true
 *
 * @param input - Action details to log
 * @returns Result with intent hash and feed entry ID
 */
export async function logAction(input: ActionLogInput): Promise<ActionLogResult> {
  // Check feature flag
  if (!isFeatureEnabled('skillLogging')) {
    logger.debug('Skill logging disabled, skipping action log');
    return {
      attempted: false,
      success: false,
      intentHash: null,
    };
  }

  // Generate intent hash
  const intentHash = generateIntentHash(input.messageText);

  try {
    let feedId: string;

    if (input.existingFeedId) {
      // Bug A fix: Use existing Feed entry from createAuditTrail instead of creating a duplicate
      feedId = input.existingFeedId;
      logger.debug('Using existing Feed entry for action log (dual-write prevention)', { feedId });
    } else {
      // No existing entry â€” create one (standalone logAction calls, e.g. from classify)
      const entrySummary = input.entrySummary || input.messageText.substring(0, 100);

      const properties: Record<string, unknown> = {
        'Entry': {
          title: [{ text: { content: entrySummary } }],
        },
        'Pillar': {
          select: { name: input.pillar || 'The Grove' },
        },
        'Request Type': {
          select: { name: input.requestType },
        },
        'Source': {
          select: { name: 'Telegram' },
        },
        'Author': {
          select: { name: 'Atlas [Telegram]' },
        },
        'Confidence': {
          number: input.confidence,
        },
        'Status': {
          select: { name: 'Routed' },
        },
        'Date': {
          date: { start: new Date().toISOString() },
        },
      };

      if (input.keywords && input.keywords.length > 0) {
        properties['Keywords'] = {
          multi_select: input.keywords.slice(0, 5).map(k => ({ name: k })),
        };
      }

      if (input.workType) {
        properties['Work Type'] = {
          rich_text: [{ text: { content: input.workType } }],
        };
      }

      const response = await notion.pages.create({
        parent: { database_id: FEED_DATABASE_ID },
        properties: properties as Parameters<typeof notion.pages.create>[0]['properties'],
      });

      feedId = response.id;
      logger.debug('Base Feed entry created for action log', { feedId });
    }

    // Now update with pattern-specific fields
    // These are in a separate update to be resilient to schema differences
    const patternProps: Record<string, unknown> = {};

    // Intent Hash - core field for pattern matching
    patternProps['Intent Hash'] = {
      rich_text: [{ text: { content: intentHash.hash } }],
    };

    // Action Type
    patternProps['Action Type'] = {
      select: { name: input.actionType },
    };

    // Tools Used
    if (input.toolsUsed.length > 0) {
      patternProps['Tools Used'] = {
        rich_text: [{ text: { content: input.toolsUsed.join(', ') } }],
      };
    }

    // Classification tracking
    if (input.classificationConfirmed !== undefined) {
      patternProps['Classification Confirmed'] = {
        checkbox: input.classificationConfirmed,
      };
    }

    if (input.classificationAdjusted !== undefined) {
      patternProps['Classification Adjusted'] = {
        checkbox: input.classificationAdjusted,
      };
    }

    if (input.originalSuggestion) {
      patternProps['Original Suggestion'] = {
        rich_text: [{ text: { content: input.originalSuggestion } }],
      };
    }

    // Execution time
    if (input.executionTimeMs !== undefined) {
      patternProps['Execution Time'] = {
        number: input.executionTimeMs,
      };
    }

    // Content analysis fields
    if (input.contentType) {
      patternProps['Content Type'] = {
        select: { name: input.contentType },
      };
    }

    if (input.contentSource) {
      patternProps['Content Source'] = {
        rich_text: [{ text: { content: input.contentSource } }],
      };
    }

    // Triage Intelligence fields
    if (input.triageIntent) {
      patternProps['Triage Intent'] = {
        select: { name: input.triageIntent },
      };
    }

    if (input.triageComplexityTier !== undefined) {
      patternProps['Triage Complexity'] = {
        select: { name: `Tier ${input.triageComplexityTier}` },
      };
    }

    if (input.triageSource) {
      patternProps['Triage Source'] = {
        select: { name: input.triageSource },
      };
    }

    if (input.triageSuggestedPillar) {
      patternProps['Triage Suggested Pillar'] = {
        rich_text: [{ text: { content: input.triageSuggestedPillar } }],
      };
    }

    if (input.triagePillarCorrected !== undefined) {
      patternProps['Triage Pillar Corrected'] = {
        rich_text: [{ text: { content: input.triagePillarCorrected ? 'Yes' : 'No' } }],
      };
    }

    if (input.triageLatencyMs !== undefined) {
      patternProps['Triage Latency'] = {
        number: input.triageLatencyMs,
      };
    }

    if (input.triageTitle) {
      patternProps['Triage Title'] = {
        rich_text: [{ text: { content: input.triageTitle } }],
      };
    }

    // Intent-First Structured Context fields
    if (input.structuredContext) {
      const ctx = input.structuredContext;
      const cap = (s: string) => s.charAt(0).toUpperCase() + s.slice(1);
      patternProps['Intent'] = { select: { name: cap(ctx.intent) } };
      patternProps['Depth'] = { select: { name: cap(ctx.depth) } };
      patternProps['Audience'] = { select: { name: cap(ctx.audience) } };
      patternProps['Source Type'] = { select: { name: cap(ctx.source_type) } };
      if (ctx.format) {
        patternProps['Format'] = { select: { name: cap(ctx.format) } };
      }
    }

    // Update with pattern fields (non-fatal if some don't exist)
    try {
      await notion.pages.update({
        page_id: feedId,
        properties: patternProps as Parameters<typeof notion.pages.update>[0]['properties'],
      });
      logger.debug('Pattern fields added to Feed entry', {
        feedId,
        intentHash: intentHash.hash,
        actionType: input.actionType,
      });
    } catch (updateError) {
      // Non-fatal: base entry exists, pattern fields may not all exist in schema
      logger.warn('Some pattern fields not added (properties may not exist in Notion)', {
        feedId,
        intentHash: intentHash.hash,
        error: updateError instanceof Error ? updateError.message : String(updateError),
        attemptedFields: Object.keys(patternProps),
      });
    }

    logger.info('Action logged to Feed 2.0', {
      feedId,
      intentHash: intentHash.hash,
      actionType: input.actionType,
      pillar: input.pillar,
      requestType: input.requestType,
      toolsUsed: input.toolsUsed,
    });

    return {
      attempted: true,
      success: true,
      intentHash,
      feedId,
    };

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);

    logger.error('Failed to log action to Feed 2.0', {
      error: errorMessage,
      intentHash: intentHash.hash,
      actionType: input.actionType,
    });

    return {
      attempted: true,
      success: false,
      intentHash,
      error: errorMessage,
    };
  }
}

/**
 * Log a classification action (convenience wrapper)
 */
export async function logClassification(
  messageText: string,
  pillar: Pillar,
  requestType: RequestType,
  confidence: number,
  userId: number,
  options?: {
    keywords?: string[];
    workType?: string;
    confirmed?: boolean;
    adjusted?: boolean;
    originalSuggestion?: string;
    executionTimeMs?: number;
  }
): Promise<ActionLogResult> {
  return logAction({
    messageText,
    pillar,
    requestType,
    actionType: 'classify',
    toolsUsed: [],
    userId,
    confidence,
    keywords: options?.keywords,
    workType: options?.workType,
    classificationConfirmed: options?.confirmed,
    classificationAdjusted: options?.adjusted,
    originalSuggestion: options?.originalSuggestion,
    executionTimeMs: options?.executionTimeMs,
  });
}

/**
 * Log a tool execution action (convenience wrapper)
 */
export async function logToolExecution(
  messageText: string,
  pillar: Pillar,
  requestType: RequestType,
  toolsUsed: string[],
  userId: number,
  confidence: number,
  executionTimeMs?: number
): Promise<ActionLogResult> {
  return logAction({
    messageText,
    pillar,
    requestType,
    actionType: 'tool',
    toolsUsed,
    userId,
    confidence,
    executionTimeMs,
  });
}

/**
 * Log a media processing action (convenience wrapper)
 */
export async function logMediaAction(
  messageText: string,
  pillar: Pillar,
  contentType: 'image' | 'document' | 'url' | 'video' | 'audio',
  userId: number,
  options?: {
    contentSource?: string;
    toolsUsed?: string[];
    executionTimeMs?: number;
  }
): Promise<ActionLogResult> {
  return logAction({
    messageText,
    pillar,
    requestType: 'Process',
    actionType: 'media',
    toolsUsed: options?.toolsUsed || [],
    userId,
    confidence: 0.8,
    contentType,
    contentSource: options?.contentSource,
    executionTimeMs: options?.executionTimeMs,
  });
}

/**
 * Get intent hash for a message (without logging)
 * Useful for pattern matching and deduplication
 */
export function getIntentHash(messageText: string): IntentHashResult {
  return generateIntentHash(messageText);
}

/**
 * Log a triage action with full triage intelligence metadata
 *
 * Use this when the triage skill was used to classify content.
 * Records intent, complexity tier, source, and correction status.
 */
export async function logTriageAction(
  messageText: string,
  pillar: Pillar,
  requestType: RequestType,
  userId: number,
  triageResult: {
    intent: 'command' | 'capture' | 'query' | 'clarify';
    confidence: number;
    complexityTier: 0 | 1 | 2 | 3;
    source: 'pattern_cache' | 'haiku';
    suggestedPillar?: Pillar;
    title?: string;
    latencyMs?: number;
    keywords?: string[];
  },
  options?: {
    pillarCorrected?: boolean;
    workType?: string;
    contentType?: 'image' | 'document' | 'url' | 'video' | 'audio';
    contentSource?: string;
    executionTimeMs?: number;
  }
): Promise<ActionLogResult> {
  return logAction({
    messageText,
    pillar,
    requestType,
    actionType: 'classify',
    toolsUsed: ['triage-skill'],
    userId,
    confidence: triageResult.confidence,
    keywords: triageResult.keywords,
    workType: options?.workType,
    contentType: options?.contentType,
    contentSource: options?.contentSource,
    executionTimeMs: options?.executionTimeMs,
    classificationConfirmed: !options?.pillarCorrected,
    classificationAdjusted: options?.pillarCorrected,
    originalSuggestion: options?.pillarCorrected ? triageResult.suggestedPillar : undefined,
    // Triage-specific fields
    triageIntent: triageResult.intent,
    triageComplexityTier: triageResult.complexityTier,
    triageSource: triageResult.source,
    triageSuggestedPillar: triageResult.suggestedPillar,
    triagePillarCorrected: options?.pillarCorrected,
    triageLatencyMs: triageResult.latencyMs,
    triageTitle: triageResult.title,
  });
}
